import os, sys, bpy, math
directory = os.path.dirname(bpy.data.filepath)
if not directory in sys.path:
    sys.path.append(directory)
from MAIN import *
from V import *
##############################################

UNDERPASS_HALLWAY_WIDTH = 5
UNDERPASS_HALLWAY_HEIGHT = 3
UNDERPASS_HALLWAY_DEPTH = 1
UNDERPASS_ENTRANCE_TOP = 0.2
UNDERPASS_ENTRANCE_BORDER = 0.3
UNDERPASS_ENTRANCE_WIDTH = 3
UNDERPASS_ENTRANCE_SLOPE = 10
UNDERPASS_ENTRANCE_STAIRS = 5
UNDERPASS_STEP_LENGTH = 0.3
UNDERPASS_STEP_HEIGHT = 0.2
STREET_SIDEWALK_WIDTH = 3
STREET_CURB_WIDTH = 0.3
STREET_CURB_HEIGHT = 0.2
STREET_LANE_WIDTH = 4
STREET_BUS_START = 15
STREET_BUS_LENGTH = 20
STREET_BUS_END = 10

class Metro(Map):
    def __init__(self) -> None:
        super().__init__()
        Scene.clear()
        self.UNDERPASS_SLOPE(V.LEFT * UNDERPASS_ENTRANCE_SLOPE)
        self.UNDERPASS_STAIRS(V.RIGHT * UNDERPASS_HALLWAY_WIDTH)
        self.UNDERPASS_HALL(V.ZERO)
        self.UNDERPASS_SIDEWALK(V.LEFT * UNDERPASS_ENTRANCE_SLOPE + V.FORWARD * STREET_SIDEWALK_WIDTH)
        self.BUS_STOP(V.FORWARD * STREET_SIDEWALK_WIDTH + V.RIGHT * (UNDERPASS_HALLWAY_WIDTH + UNDERPASS_ENTRANCE_STAIRS))
        self.create("Metro")
    def UNDERPASS_SLOPE(self, S: V = V(0, 0, 0)) -> None:
        # Outer points
        TLO = S
        TRO = TLO + UNDERPASS_ENTRANCE_SLOPE * V.RIGHT
        BRO = TRO + UNDERPASS_ENTRANCE_WIDTH * V.BACKWARD
        BLO = BRO + UNDERPASS_ENTRANCE_SLOPE * V.LEFT
        # Inner points
        TRI = TRO + UNDERPASS_ENTRANCE_BORDER * (V.LEFT + V.BACKWARD)
        TLI = TLO + UNDERPASS_ENTRANCE_BORDER * V.BACKWARD
        BRI = BRO + UNDERPASS_ENTRANCE_BORDER * (V.LEFT + V.FORWARD)
        BLI = BLO + UNDERPASS_ENTRANCE_BORDER * V.FORWARD
        # Upper points
        TRO1, TLO1, BRO1, BLO1, TRI1, TLI1, BRI1, BLI1 = (x + UNDERPASS_ENTRANCE_TOP * V.UP for x in (TRO, TLO, BRO, BLO, TRI, TLI, BRI, BLI))
        self.face([TLO1, TRO1, BRO1, BLO1, BLI1, BRI1, TRI1, TLI1][::-1])
        # Outer walls
        self.face([TLO, TLI, TLI1, TLO1])
        self.face([TLO, TRO, TRO1, TLO1][::-1])
        self.face([TRO, BRO, BRO1, TRO1][::-1])
        self.face([BLO, BRO, BRO1, BLO1])
        self.face([BLO, BLI, BLI1, BLO1][::-1])
        # Lower points
        TRIC = TRI + UNDERPASS_HALLWAY_DEPTH * V.DOWN
        TRIF = TRIC + UNDERPASS_HALLWAY_HEIGHT * V.DOWN
        BRIC = BRI + UNDERPASS_HALLWAY_DEPTH * V.DOWN
        BRIF = BRIC + UNDERPASS_HALLWAY_HEIGHT * V.DOWN
        self.face([BLI, TLI, TRIF, BRIF][::-1])
        self.face([TRI1, BRI1, BRIC, TRIC][::-1])
        TROC = TRO + UNDERPASS_ENTRANCE_BORDER * V.BACKWARD + UNDERPASS_HALLWAY_DEPTH * V.DOWN
        TROF = TROC + UNDERPASS_HALLWAY_HEIGHT * V.DOWN
        BROC = BRO + UNDERPASS_ENTRANCE_BORDER * V.FORWARD + UNDERPASS_HALLWAY_DEPTH * V.DOWN
        BROF = BROC + UNDERPASS_HALLWAY_HEIGHT * V.DOWN
        self.face([TLI1, TLI, TRIF, TROF, TROC, TRIC, TRI1])
        self.face([BLI, BLI1, BRI1, BRIC, BROC, BROF, BRIF])
        #self.face([TRIF, TROF, BROF, BRIF][::-1]) #####
        #self.face([TRIC, TROC, BROC, BRIC]) #####
    def UNDERPASS_STAIRS(self, S: V = (0, 0, 0)) -> None:
        # Outer points
        TLO = S
        TRO = TLO + UNDERPASS_ENTRANCE_STAIRS * V.RIGHT
        BLO = TLO + UNDERPASS_ENTRANCE_WIDTH * V.BACKWARD
        BRO = BLO + UNDERPASS_ENTRANCE_STAIRS * V.RIGHT
        # Inner points
        TLI = TLO + UNDERPASS_ENTRANCE_BORDER * (V.RIGHT + V.BACKWARD)
        TRI = TRO + UNDERPASS_ENTRANCE_BORDER * V.BACKWARD
        BLI = BLO + UNDERPASS_ENTRANCE_BORDER * (V.RIGHT + V.FORWARD)
        BRI = BRO + UNDERPASS_ENTRANCE_BORDER * V.FORWARD
        # Upper points
        TLO1, TRO1, BLO1, BRO1, TLI1, TRI1, BLI1, BRI1 = (x + UNDERPASS_ENTRANCE_TOP * V.UP for x in (TLO, TRO, BLO, BRO, TLI, TRI, BLI, BRI))
        self.face([TRO1, TLO1, BLO1, BRO1, BRI1, BLI1, TLI1, TRI1])
        # Outer walls
        self.face([TRO, TRI, TRI1, TRO1][::-1])
        self.face([TRO, TLO, TLO1, TRO1])
        self.face([TLO, BLO, BLO1, TLO1])
        self.face([BRO, BLO, BLO1, BRO1][::-1])
        self.face([BRO, BRI, BRI1, BRO1])
        # Lower points
        TLIC = TLI + UNDERPASS_HALLWAY_DEPTH * V.DOWN
        TLIF = TLIC + UNDERPASS_HALLWAY_HEIGHT * V.DOWN
        BLIC = BLI + UNDERPASS_HALLWAY_DEPTH * V.DOWN
        BLIF = BLIC + UNDERPASS_HALLWAY_HEIGHT * V.DOWN
        self.face([TLI1, BLI1, BLIC, TLIC])
        TLOC = TLO + UNDERPASS_ENTRANCE_BORDER * V.BACKWARD + UNDERPASS_HALLWAY_DEPTH * V.DOWN
        TLOF = TLOC + UNDERPASS_HALLWAY_HEIGHT * V.DOWN
        BLOC = BLO + UNDERPASS_ENTRANCE_BORDER * V.FORWARD + UNDERPASS_HALLWAY_DEPTH * V.DOWN
        BLOF = BLOC + UNDERPASS_HALLWAY_HEIGHT * V.DOWN
        #self.face([TLIF, TLOF, BLOF, BLIF]) #####
        #self.face([TLIC, TLOC, BLOC, BLIC][::-1]) #####
        # Steps
        H = UNDERPASS_HALLWAY_HEIGHT + UNDERPASS_HALLWAY_DEPTH
        L = UNDERPASS_ENTRANCE_STAIRS - UNDERPASS_ENTRANCE_BORDER
        C = round((H/UNDERPASS_STEP_HEIGHT + L/UNDERPASS_STEP_LENGTH)/2)
        T = []
        B = []
        for c in range(C):
            TS = TLIF + (c/C*L) * V.RIGHT + ((c+1)/C*H) * V.UP
            BS = BLIF + (c/C*L) * V.RIGHT + ((c+1)/C*H) * V.UP
            TL = TLIF + (c/C*L) * V.RIGHT + (c/C*H) * V.UP
            BL = BLIF + (c/C*L) * V.RIGHT + (c/C*H) * V.UP
            self.face([TL, BL, BS, TS])
            self.face([
                TLIF + ((c+1)/C*L) * V.RIGHT + ((c+1)/C*H) * V.UP,
                BLIF + ((c+1)/C*L) * V.RIGHT + ((c+1)/C*H) * V.UP,
                BS, TS
            ][::-1])
            T += [TL, TS]
            B += [BL, BS]
        self.face(T + [TRI, TRI1, TLI1, TLIC, TLOC, TLOF])
        self.face((B + [BRI, BRI1, BLI1, BLIC, BLOC, BLOF])[::-1])
    def UNDERPASS_HALL(self, S: V = (0, 0, 0)) -> None:
        # Left backward wall
        BLF = S + (UNDERPASS_HALLWAY_DEPTH + UNDERPASS_HALLWAY_HEIGHT) * V.DOWN + (UNDERPASS_ENTRANCE_WIDTH + STREET_SIDEWALK_WIDTH) * V.BACKWARD
        BLC = S + UNDERPASS_HALLWAY_DEPTH * V.DOWN + (UNDERPASS_ENTRANCE_WIDTH + STREET_SIDEWALK_WIDTH) * V.BACKWARD
        BLCF = S + (UNDERPASS_HALLWAY_DEPTH + UNDERPASS_HALLWAY_HEIGHT) * V.DOWN + (UNDERPASS_ENTRANCE_WIDTH - UNDERPASS_ENTRANCE_BORDER) * V.BACKWARD
        BLCC = S + UNDERPASS_HALLWAY_DEPTH * V.DOWN + (UNDERPASS_ENTRANCE_WIDTH - UNDERPASS_ENTRANCE_BORDER) * V.BACKWARD
        self.face([BLF, BLC, BLCC, BLCF][::-1])
        # Left forward wall
        TLF = S + (UNDERPASS_HALLWAY_DEPTH + UNDERPASS_HALLWAY_HEIGHT) * V.DOWN + STREET_SIDEWALK_WIDTH * V.FORWARD
        TLC = S + UNDERPASS_HALLWAY_DEPTH * V.DOWN + STREET_SIDEWALK_WIDTH * V.FORWARD
        TLCF = S + (UNDERPASS_HALLWAY_DEPTH + UNDERPASS_HALLWAY_HEIGHT) * V.DOWN + UNDERPASS_ENTRANCE_BORDER * V.BACKWARD
        TLCC = S + UNDERPASS_HALLWAY_DEPTH * V.DOWN + UNDERPASS_ENTRANCE_BORDER * V.BACKWARD
        self.face([TLF, TLC, TLCC, TLCF])
        # Right backward wall
        BRF = S + (UNDERPASS_HALLWAY_DEPTH + UNDERPASS_HALLWAY_HEIGHT) * V.DOWN + (UNDERPASS_ENTRANCE_WIDTH + STREET_SIDEWALK_WIDTH) * V.BACKWARD + UNDERPASS_HALLWAY_WIDTH * V.RIGHT
        BRC = S + UNDERPASS_HALLWAY_DEPTH * V.DOWN + (UNDERPASS_ENTRANCE_WIDTH + STREET_SIDEWALK_WIDTH) * V.BACKWARD + UNDERPASS_HALLWAY_WIDTH * V.RIGHT
        BRCF = S + (UNDERPASS_HALLWAY_DEPTH + UNDERPASS_HALLWAY_HEIGHT) * V.DOWN + (UNDERPASS_ENTRANCE_WIDTH - UNDERPASS_ENTRANCE_BORDER) * V.BACKWARD + UNDERPASS_HALLWAY_WIDTH * V.RIGHT
        BRCC = S + UNDERPASS_HALLWAY_DEPTH * V.DOWN + (UNDERPASS_ENTRANCE_WIDTH - UNDERPASS_ENTRANCE_BORDER) * V.BACKWARD + UNDERPASS_HALLWAY_WIDTH * V.RIGHT
        self.face([BRF, BRC, BRCC, BRCF])
        # Left forward wall
        TRF = S + (UNDERPASS_HALLWAY_DEPTH + UNDERPASS_HALLWAY_HEIGHT) * V.DOWN + STREET_SIDEWALK_WIDTH * V.FORWARD + UNDERPASS_HALLWAY_WIDTH * V.RIGHT
        TRC = S + UNDERPASS_HALLWAY_DEPTH * V.DOWN + STREET_SIDEWALK_WIDTH * V.FORWARD + UNDERPASS_HALLWAY_WIDTH * V.RIGHT
        TRCF = S + (UNDERPASS_HALLWAY_DEPTH + UNDERPASS_HALLWAY_HEIGHT) * V.DOWN + UNDERPASS_ENTRANCE_BORDER * V.BACKWARD + UNDERPASS_HALLWAY_WIDTH * V.RIGHT
        TRCC = S + UNDERPASS_HALLWAY_DEPTH * V.DOWN + UNDERPASS_ENTRANCE_BORDER * V.BACKWARD + UNDERPASS_HALLWAY_WIDTH * V.RIGHT
        self.face([TRF, TRC, TRCC, TRCF][::-1])
        # Floor & ceiling
        CEIL = [
            BLF, BLCF,
            BLCF + UNDERPASS_ENTRANCE_BORDER * V.LEFT,
            TLCF + UNDERPASS_ENTRANCE_BORDER * V.LEFT,
            TLCF, TLF, TRF, TRCF,
            TRCF + UNDERPASS_ENTRANCE_BORDER * V.RIGHT,
            BRCF + UNDERPASS_ENTRANCE_BORDER * V.RIGHT,
            BRCF, BRF
        ]
        self.face([x + UNDERPASS_HALLWAY_HEIGHT * V.UP for x in CEIL])
        self.face(CEIL[::-1])
    def UNDERPASS_SIDEWALK(self, S: V = (0, 0, 0)) -> None:
        # Sidewalk
        TLO = S
        TLI = TLO + STREET_SIDEWALK_WIDTH * V.BACKWARD
        TLIC = TLI + UNDERPASS_ENTRANCE_SLOPE * V.RIGHT
        BLIC = TLIC + UNDERPASS_ENTRANCE_WIDTH * V.BACKWARD
        BLI = BLIC + UNDERPASS_ENTRANCE_SLOPE * V.LEFT
        BLO = BLI + (STREET_LANE_WIDTH - UNDERPASS_ENTRANCE_WIDTH - STREET_CURB_WIDTH) * V.BACKWARD
        BRO = BLO + (UNDERPASS_ENTRANCE_SLOPE + UNDERPASS_HALLWAY_WIDTH + UNDERPASS_ENTRANCE_STAIRS) * V.RIGHT
        BRI = BRO + (STREET_LANE_WIDTH - UNDERPASS_ENTRANCE_WIDTH - STREET_CURB_WIDTH) * V.FORWARD
        BRIC = BRI + UNDERPASS_ENTRANCE_STAIRS * V.LEFT
        TRIC = BRIC + UNDERPASS_ENTRANCE_WIDTH * V.FORWARD
        TRI = TRIC + UNDERPASS_ENTRANCE_STAIRS * V.RIGHT
        TRO = TRI + STREET_SIDEWALK_WIDTH * V.FORWARD
        self.face([TLO, TLI, TLIC, BLIC, BLI, BLO, BRO, BRI, BRIC, TRIC, TRI, TRO])
        # Curb
        BLC = S + (STREET_LANE_WIDTH + STREET_SIDEWALK_WIDTH) * V.BACKWARD
        BLCC = BLC + STREET_CURB_HEIGHT * V.DOWN
        BRC = BLC + (UNDERPASS_ENTRANCE_SLOPE + UNDERPASS_HALLWAY_WIDTH + UNDERPASS_ENTRANCE_STAIRS) * V.RIGHT
        BRCC = BRC + STREET_CURB_HEIGHT * V.DOWN
        self.face([BLO, BLC, BRC, BRO])
        self.face([BLC, BLCC, BRCC, BRC])
    def BUS_STOP(self, S: V = (0, 0, 0)) -> None:
        # Sidewalk
        TL = S
        BL = TL + (STREET_SIDEWALK_WIDTH + STREET_LANE_WIDTH) * V.BACKWARD
        BLI = BL + STREET_CURB_WIDTH * V.FORWARD
        TR = TL + (STREET_BUS_START + STREET_BUS_LENGTH + STREET_BUS_END) * V.RIGHT
        BR = TR + (STREET_SIDEWALK_WIDTH + STREET_LANE_WIDTH) * V.BACKWARD
        BRI = BR + STREET_CURB_WIDTH * V.FORWARD
        LCI = TL + STREET_BUS_END * V.RIGHT + STREET_SIDEWALK_WIDTH * V.BACKWARD
        RCI = TR + STREET_BUS_START * V.LEFT + STREET_SIDEWALK_WIDTH * V.BACKWARD
        self.face([TL, TR, BRI, RCI, LCI, BLI][::-1])
        # Curb

Metro()